name: Release and Publish

on:
  push:
    tags:
      - 'v*'

jobs:
  publish-npm:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'
          
      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "CLEAN_VERSION=${VERSION#v}" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Setup GitHub API functions
        run: |
          # Create a reusable function for downloading private release assets
          cat > download_asset.sh << 'EOF'
          #!/bin/bash
          download_private_asset() {
            local filename=$1
            local output_path=$2
            local repo="allnationconnect/kaitu"
            local version="${{ steps.get_version.outputs.VERSION }}"
            
            echo "Downloading $filename from private release..."
            
            # Get asset ID
            ASSET_ID=$(curl -s -H "Authorization: Bearer ${{ secrets.GH_PAT_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$repo/releases/tags/$version" \
                | jq -r --arg filename "$filename" '.assets[] | select(.name==$filename) | .id')
            
            if [ "$ASSET_ID" = "null" ] || [ -z "$ASSET_ID" ]; then
              echo "ERROR: $filename not found in release assets"
              return 1
            fi
            
            echo "Found $filename with asset ID: $ASSET_ID"
            
            # Download asset
            HTTP_CODE=$(curl -w "%{http_code}" -s \
                -H "Authorization: Bearer ${{ secrets.GH_PAT_TOKEN }}" \
                -H "Accept: application/octet-stream" \
                -L "https://api.github.com/repos/$repo/releases/assets/$ASSET_ID" \
                -o "$output_path")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Successfully downloaded $filename ($(wc -c < "$output_path") bytes)"
              return 0
            else
              echo "ERROR: Failed to download $filename (HTTP $HTTP_CODE)"
              rm -f "$output_path"
              return 1
            fi
          }
          EOF
          
          chmod +x download_asset.sh
          source download_asset.sh
          
      - name: Download required JSON files
        run: |
          source download_asset.sh
          echo "Downloading required JSON configuration files..."
               
          # Download service.latest.json (required)
          if ! download_private_asset "service.latest.json" "service.latest.json"; then
            echo "ERROR: Cannot proceed without service.latest.json"
            exit 1
          fi
          
          echo "Downloaded service.latest.json size: $(wc -c < service.latest.json) bytes"
          echo "Content of service.latest.json:"
          cat service.latest.json
          echo "--- End of service.latest.json ---"
          
          if ! jq . service.latest.json > /dev/null 2>&1; then
            echo "ERROR: service.latest.json is not valid JSON"
            exit 1
          fi
          echo "✓ service.latest.json downloaded and validated successfully"
          
          # Download installer.latest.json (required)
          if ! download_private_asset "installer.latest.json" "installer.latest.json"; then
            echo "ERROR: Cannot proceed without installer.latest.json"
            exit 1
          fi
          
          echo "Downloaded installer.latest.json size: $(wc -c < installer.latest.json) bytes"
          echo "Content of installer.latest.json:"
          cat installer.latest.json
          echo "--- End of installer.latest.json ---"
          
          if ! jq . installer.latest.json > /dev/null 2>&1; then
            echo "ERROR: installer.latest.json is not valid JSON"
            exit 1
          fi
          echo "✓ installer.latest.json downloaded and validated successfully"
          
          # Download updater.latest.json (required)
          if ! download_private_asset "updater.latest.json" "updater.latest.json"; then
            echo "ERROR: Cannot proceed without updater.latest.json"
            exit 1
          fi
          
          echo "Downloaded updater.latest.json size: $(wc -c < updater.latest.json) bytes"
          echo "Content of updater.latest.json:"
          cat updater.latest.json
          echo "--- End of updater.latest.json ---"
          
          if ! jq . updater.latest.json > /dev/null 2>&1; then
            echo "ERROR: updater.latest.json is not valid JSON"
            exit 1
          fi
          echo "✓ updater.latest.json downloaded and validated successfully"
               
      - name: Create npm directory if not exists
        run: mkdir -p npm
        
      - name: Initialize package.json with correct version
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          CLEAN_VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          # Copy the base package.json from the repo
          cp npm/package.json npm/package.json.backup
          
          # Initialize with correct name and version
          jq --arg name "kaitu" --arg version "$CLEAN_VERSION" '.name = $name | .version = $version' npm/package.json > npm/package.json.tmp
          mv npm/package.json.tmp npm/package.json
          
          echo "Initialized package.json with correct version:"
          echo "Tag: $VERSION -> Package version: $CLEAN_VERSION"
          cat npm/package.json
          
      - name: Create Python JSON processing script
        run: |
          cat > process_json.py << 'EOF'
          #!/usr/bin/env python3
          import json
          import sys
          from urllib.parse import urlparse
          
          def extract_filename_from_url(url):
              """Extract filename from URL"""
              return urlparse(url).path.split('/')[-1]
          
          def get_all_files_from_json(json_data):
              """Extract all filenames from platforms in JSON or direct platform URLs"""
              files = set()
              
              # Handle updater.latest.json format (has platforms key)
              if 'platforms' in json_data:
                  for platform_data in json_data['platforms'].values():
                      if 'url' in platform_data:
                          filename = extract_filename_from_url(platform_data['url'])
                          files.add(filename)
              
              # Handle service.latest.json and installer.latest.json format (direct platform keys)
              else:
                  for platform_key, platform_data in json_data.items():
                      if isinstance(platform_data, dict) and 'url' in platform_data:
                          filename = extract_filename_from_url(platform_data['url'])
                          files.add(filename)
              
              return sorted(list(files))
          
          def merge_package_json(base_package, service_data, installer_data, updater_data, version):
              """Create final package.json with proper structure"""
              result = {
                  "name": "kaitu",
                  "version": version,
                  "description": "Kaitu - Cross-platform desktop application and service",
                  "main": "index.js",
                  "keywords": ["kaitu", "desktop", "service", "proxy", "cross-platform"],
                  "author": "AllNation Connect",
                  "license": "ISC",
                  "bin": {},
                  "scripts": {
                      "test": "echo \"Error: no test specified\" && exit 1"
                  },
                  "repository": {
                      "type": "git",
                      "url": "https://github.com/allnationconnect/kaitu"
                  }
              }
              
              # Add service data under "service" key
              if service_data:
                  result["service"] = service_data
              
              # Add installer data under "installer" key
              if installer_data:
                  result["installer"] = installer_data
              
              # Add updater data directly to root level (except name/version) - highest priority
              if updater_data:
                  for key, value in updater_data.items():
                      if key not in ["name", "version"]:  # Don't override name/version
                          result[key] = value
              
              return result
          
          if __name__ == "__main__":
              command = sys.argv[1] if len(sys.argv) > 1 else ""
              
              if command == "extract_files":
                  # Extract files from all JSON files
                  all_files = []
                  import os
                  
                  # Extract from service.latest.json
                  if os.path.exists('service.latest.json'):
                      with open('service.latest.json', 'r') as f:
                          service_data = json.load(f)
                      service_files = get_all_files_from_json(service_data)
                      all_files.extend(service_files)
                      print("Files from service.latest.json:")
                      for f in service_files:
                          print(f)
                  
                  # Extract from installer.latest.json
                  if os.path.exists('installer.latest.json'):
                      with open('installer.latest.json', 'r') as f:
                          installer_data = json.load(f)
                      installer_files = get_all_files_from_json(installer_data)
                      all_files.extend(installer_files)
                      print("\nFiles from installer.latest.json:")
                      for f in installer_files:
                          print(f)
                  
                  # Extract from updater.latest.json
                  if os.path.exists('updater.latest.json'):
                      with open('updater.latest.json', 'r') as f:
                          updater_data = json.load(f)
                      updater_files = get_all_files_from_json(updater_data)
                      all_files.extend(updater_files)
                      print("\nFiles from updater.latest.json:")
                      for f in updater_files:
                          print(f)
                  
                  # Remove duplicates and sort
                  all_files = sorted(list(set(all_files)))
                  
                  print("\nAll unique files:")
                  for f in all_files:
                      print(f)
                  
                  # Write to file for shell script
                  with open('/tmp/all_files.txt', 'w') as f:
                      f.write('\n'.join(all_files))
              
              elif command == "merge_package":
                  import os
                  version = sys.argv[2]
                  
                  # Load base package.json
                  with open('npm/package.json', 'r') as f:
                      base_package = json.load(f)
                  
                  # Load service.latest.json
                  service_data = None
                  if os.path.exists('service.latest.json'):
                      with open('service.latest.json', 'r') as f:
                          service_data = json.load(f)
                  
                  # Load installer.latest.json
                  installer_data = None
                  if os.path.exists('installer.latest.json'):
                      with open('installer.latest.json', 'r') as f:
                          installer_data = json.load(f)
                  
                  # Load updater.latest.json
                  updater_data = None
                  if os.path.exists('updater.latest.json'):
                      with open('updater.latest.json', 'r') as f:
                          updater_data = json.load(f)
                  
                  # Create merged package.json
                  result = merge_package_json(base_package, service_data, installer_data, updater_data, version)
                  
                  # Write result
                  with open('npm/package.json', 'w') as f:
                      json.dump(result, f, indent=2)
                  
                  print("Updated package.json:")
                  print(json.dumps(result, indent=2))
          EOF
          
          chmod +x process_json.py
          
      - name: Merge JSON data into package.json
        run: |
          echo "Merging all JSON files into package.json using Python..."
          
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          CLEAN_VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          echo "Reading JSON files..."
          echo "service.latest.json:"
          cat service.latest.json
          echo ""
          
          echo "installer.latest.json:"
          cat installer.latest.json
          echo ""
          
          echo "updater.latest.json:"
          cat updater.latest.json
          echo ""
          
          # Use Python script to merge JSON data
          python3 process_json.py merge_package "$CLEAN_VERSION"
          
          echo ""
          echo "Final package.json structure:"
          echo "- updater.latest.json: keys directly added to package.json root (highest priority)"
          echo "- installer: all installer.latest.json content under 'installer' key"
          echo "- service: all service.latest.json content under 'service' key"
          echo "- version: $CLEAN_VERSION (from tag $VERSION)"
          
      - name: Extract and download files using Python
        run: |
          echo "Extracting file names from platform URLs using Python..."
          
          # Use Python script to extract all files
          python3 process_json.py extract_files
          
          # Read the extracted file list
          if [ ! -f /tmp/all_files.txt ]; then
            echo "ERROR: No files extracted from JSON files"
            exit 1
          fi
          
          # Download each file
          echo ""
          echo "Downloading all files..."
          DOWNLOAD_FAILED=false
          source download_asset.sh
          
          while IFS= read -r file; do
            if [ -n "$file" ]; then
              echo "Downloading: $file"
              if ! download_private_asset "$file" "npm/$file"; then
                echo "Failed to download $file"
                DOWNLOAD_FAILED=true
              fi
            fi
          done < /tmp/all_files.txt
          
          # Check if any downloads failed
          if [ "$DOWNLOAD_FAILED" = "true" ]; then
            echo "ERROR: One or more required files failed to download"
            echo "Cannot proceed with NPM publish without all required files"
            exit 1
          fi
          
          echo ""
          echo "Final npm directory contents:"
          ls -la npm/
          
      - name: Publish to npm
        working-directory: ./npm
        run: |
          echo "Publishing package to npm..."
          echo "Package name: $(jq -r '.name' package.json)"
          echo "Package version: $(jq -r '.version' package.json)"
          echo "Current working directory: $(pwd)"
          echo "Files in directory:"
          ls -la
          echo "Full package.json content:"
          cat package.json
          
          # Check npm authentication
          echo "Testing npm authentication..."
          npm whoami || echo "npm whoami failed"
          
          # Publish with public access for scoped package
          echo "Attempting to publish..."
          npm publish --access public --verbose || {
            echo "npm publish failed with exit code $?"
            echo "npm config:"
            npm config list
            echo "Checking .npmrc file..."
            cat ~/.npmrc || echo "No .npmrc file found"
            exit 1
          }
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_PUBLISH_TOKEN }}

  homebrew-release:
    runs-on: ubuntu-latest
    needs: publish-npm
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Extract version from tag or input
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "CLEAN_VERSION=${VERSION#v}" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Download release assets
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          echo "Downloading assets for version: $VERSION"
          
          # Create download directory
          mkdir -p downloads
          
          # Download tar.gz file (assuming it follows the pattern from build-and-package.yml)
          # We'll look for files that match common patterns
          RELEASE_URL="https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION"
          
          # Get release info
          curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               "$RELEASE_URL" \
               -o release_info.json
          
          # Extract download URLs for tar.gz files
          jq -r '.assets[] | select(.name | endswith(".tar.gz")) | .browser_download_url' release_info.json > download_urls.txt
          
          # Download the first tar.gz file found
          if [ -s download_urls.txt ]; then
            DOWNLOAD_URL=$(head -n1 download_urls.txt)
            FILENAME=$(basename "$DOWNLOAD_URL")
            echo "Downloading: $DOWNLOAD_URL"
            curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 -L "$DOWNLOAD_URL" \
                 -o "downloads/$FILENAME"
            echo "ARCHIVE_FILE=downloads/$FILENAME" >> $GITHUB_ENV
            echo "ARCHIVE_NAME=$FILENAME" >> $GITHUB_ENV
          else
            echo "No tar.gz files found in release assets"
            exit 1
          fi
          
      - name: Calculate SHA256 checksum
        id: checksum
        run: |
          CHECKSUM=$(sha256sum "$ARCHIVE_FILE" | cut -d' ' -f1)
          echo "SHA256=$CHECKSUM" >> $GITHUB_OUTPUT
          echo "Archive: $ARCHIVE_FILE"
          echo "SHA256: $CHECKSUM"
          
      - name: Generate Homebrew formula
        run: |
          VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          SHA256="${{ steps.checksum.outputs.SHA256 }}"
          ARCHIVE_NAME="${{ env.ARCHIVE_NAME }}"
          
          # Create formula directory
          mkdir -p formula
          
          cat > formula/kaitu.rb << EOF
          class Kaitu < Formula
            desc "Kaitu - A powerful application tool"
            homepage "https://github.com/${{ github.repository }}"
            url "https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${ARCHIVE_NAME}"
            sha256 "${SHA256}"
            version "${VERSION}"
          
            def install
              # Extract the archive
              system "tar", "-xzf", cached_download
              
              # Install binaries and files
              # Adjust these paths based on your application structure
              if File.exist?("kaitu")
                bin.install "kaitu"
              end
              
              # Install other files if present
              if Dir.exist?("lib")
                lib.install Dir["lib/*"]
              end
              
              if Dir.exist?("share")
                share.install Dir["share/*"]
              end
            end
          
            test do
              # Basic test to ensure the binary exists and runs
              system "#{bin}/kaitu", "--version" if File.exist?("#{bin}/kaitu")
            end
          end
          EOF
          
          echo "Generated Homebrew formula:"
          cat formula/kaitu.rb
          
      - name: Setup Git for Homebrew tap
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
      - name: Update Homebrew tap
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          HOMEBREW_TAP_REPO: ${{ secrets.HOMEBREW_TAP_REPO }}
        run: |
          VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          if [ -z "$HOMEBREW_TAP_TOKEN" ] || [ -z "$HOMEBREW_TAP_REPO" ]; then
            echo "Warning: HOMEBREW_TAP_TOKEN or HOMEBREW_TAP_REPO not set"
            echo "Please configure these secrets to enable Homebrew tap updates"
            echo "Generated formula is available in the artifacts"
            exit 0
          fi
          
          # Clone the Homebrew tap repository
          git clone https://${HOMEBREW_TAP_TOKEN}@github.com/${HOMEBREW_TAP_REPO}.git homebrew-tap
          cd homebrew-tap
          
          # Create Formula directory if it doesn't exist
          mkdir -p Formula
          
          # Copy the generated formula
          cp ../formula/kaitu.rb Formula/kaitu.rb
          
          # Commit and push changes
          git add Formula/kaitu.rb
          git commit -m "Update kaitu to version ${VERSION}"
          git tag "kaitu-${VERSION}"
          git push origin main
          git push origin "kaitu-${VERSION}"
          
          echo "Successfully updated Homebrew tap with version ${VERSION}"
          
      - name: Upload formula as artifact
        uses: actions/upload-artifact@v4
        with:
          name: homebrew-formula
          path: formula/kaitu.rb
          retention-days: 30