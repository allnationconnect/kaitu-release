name: Release and Publish

on:
  push:
    tags:
      - 'v*'

jobs:
  publish-npm:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'
          
      - name: Extract version from tag
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Download latest.json
        run: |
          echo "Downloading from: https://github.com/allnationconnect/kaitu/releases/download/${{ steps.get_version.outputs.VERSION }}/latest.json"
          
          # Use curl with fail option and better error handling
          HTTP_CODE=$(curl -w "%{http_code}" -s -H "Authorization: token ${{ secrets.GH_PAT_TOKEN }}" \
               -L https://github.com/allnationconnect/kaitu/releases/download/${{ steps.get_version.outputs.VERSION }}/latest.json \
               -o latest.json)
          
          echo "HTTP Response Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Failed to download latest.json with HTTP code: $HTTP_CODE"
            echo "Response content:"
            cat latest.json
            
            # Check if release exists
            echo "Checking if release ${{ steps.get_version.outputs.VERSION }} exists..."
            curl -H "Authorization: token ${{ secrets.GH_PAT_TOKEN }}" \
                 https://api.github.com/repos/allnationconnect/kaitu/releases/tags/${{ steps.get_version.outputs.VERSION }}
            
            echo "ERROR: latest.json not found in release assets"
            echo "Cannot proceed without latest.json - this file should contain package configuration and file list"
            exit 1
          fi
          
          echo "Downloaded latest.json size: $(wc -c < latest.json) bytes"
          echo "Content of latest.json:"
          cat latest.json
          echo "--- End of latest.json ---"
          
          # Verify downloaded file is valid JSON
          if ! jq . latest.json > /dev/null 2>&1; then
            echo "Error: latest.json is not valid JSON"
            echo "Raw content (hex dump):"
            hexdump -C latest.json | head -20
            exit 1
          fi
          echo "latest.json downloaded and validated successfully"
               
      - name: Download service.latest.json
        run: |
          echo "Downloading from: https://github.com/allnationconnect/kaitu/releases/download/${{ steps.get_version.outputs.VERSION }}/service.latest.json"
          
          # Use curl with fail option and better error handling
          HTTP_CODE=$(curl -w "%{http_code}" -s -H "Authorization: token ${{ secrets.GH_PAT_TOKEN }}" \
               -L https://github.com/allnationconnect/kaitu/releases/download/${{ steps.get_version.outputs.VERSION }}/service.latest.json \
               -o service.latest.json)
          
          echo "HTTP Response Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Failed to download service.latest.json with HTTP code: $HTTP_CODE"
            echo "Response content:"
            cat service.latest.json
            
            echo "ERROR: service.latest.json not found in release assets"
            echo "Cannot proceed without service.latest.json - this file should contain service configuration"
            exit 1
          fi
          
          echo "Downloaded service.latest.json size: $(wc -c < service.latest.json) bytes"
          echo "Content of service.latest.json:"
          cat service.latest.json
          echo "--- End of service.latest.json ---"
          
          # Verify downloaded file is valid JSON
          if ! jq . service.latest.json > /dev/null 2>&1; then
            echo "Error: service.latest.json is not valid JSON"
            echo "Raw content (hex dump):"
            hexdump -C service.latest.json | head -20
            exit 1
          fi
          echo "service.latest.json downloaded and validated successfully"
               
      - name: Create npm directory if not exists
        run: mkdir -p npm
        
      - name: Initialize package.json with correct version
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          CLEAN_VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          # Copy the base package.json from the repo
          cp npm/package.json npm/package.json.backup
          
          # Initialize with correct name and version
          jq --arg name "kaitu" --arg version "$CLEAN_VERSION" '.name = $name | .version = $version' npm/package.json > npm/package.json.tmp
          mv npm/package.json.tmp npm/package.json
          
          echo "Initialized package.json with correct version:"
          echo "Tag: $VERSION -> Package version: $CLEAN_VERSION"
          cat npm/package.json
          
      - name: Update package.json with service data
        run: |
          # Read service data and update package.json service field
          echo "Reading service.latest.json..."
          cat service.latest.json
          
          # Only update service field if service.latest.json is not empty
          if [ "$(jq 'length' service.latest.json)" -gt 0 ]; then
            echo "Updating package.json with service data..."
            jq --slurpfile service service.latest.json '.service = $service[0]' npm/package.json > npm/package.json.tmp
            mv npm/package.json.tmp npm/package.json
            echo "Updated package.json with service data:"
            jq '.service' npm/package.json
          else
            echo "service.latest.json is empty, skipping service update"
          fi
          
      - name: Update package.json with latest.json data
        run: |
          # Read latest.json and merge with package.json
          echo "Reading latest.json..."
          cat latest.json
          
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          CLEAN_VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          # Only merge latest.json if it's not empty and has meaningful content
          if [ "$(jq 'length' latest.json)" -gt 0 ]; then
            echo "Merging latest.json data into package.json..."
            # Merge but preserve name and version
            jq --slurpfile latest latest.json --arg name "kaitu" --arg version "$CLEAN_VERSION" \
               '. * $latest[0] | .name = $name | .version = $version' npm/package.json > npm/package.json.tmp
            mv npm/package.json.tmp npm/package.json
          else
            echo "latest.json is empty, skipping merge but ensuring correct name/version"
            jq --arg name "kaitu" --arg version "$CLEAN_VERSION" '.name = $name | .version = $version' npm/package.json > npm/package.json.tmp
            mv npm/package.json.tmp npm/package.json
          fi
          
          echo "Final package.json after processing:"
          echo "Tag version: $VERSION -> Package version: $CLEAN_VERSION"
          cat npm/package.json
          
      - name: Download files listed in latest.json to npm directory
        run: |
          # Extract file list from latest.json and download each file
          FILES=$(jq -r '.files[]? // empty' latest.json 2>/dev/null || echo "")
          
          if [ -n "$FILES" ]; then
            echo "Files to download from latest.json:"
            echo "$FILES"
            DOWNLOAD_FAILED=false
            
            for file in $FILES; do
              echo "Downloading $file..."
              HTTP_CODE=$(curl -w "%{http_code}" -s -H "Authorization: token ${{ secrets.GH_PAT_TOKEN }}" \
                   -L https://github.com/allnationconnect/kaitu/releases/download/${{ steps.get_version.outputs.VERSION }}/$file \
                   -o npm/$file)
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "Successfully downloaded $file ($(wc -c < npm/$file) bytes)"
              else
                echo "ERROR: Failed to download required file $file (HTTP $HTTP_CODE)"
                rm -f npm/$file  # Remove any partial/error file
                DOWNLOAD_FAILED=true
              fi
            done
            
            if [ "$DOWNLOAD_FAILED" = "true" ]; then
              echo "ERROR: One or more required files failed to download"
              echo "Cannot proceed with NPM publish without all required files"
              exit 1
            fi
          else
            echo "ERROR: No files specified in latest.json"
            echo "latest.json should contain a 'files' array with binary/executable files"
            exit 1
          fi
          
          echo "Final npm directory contents:"
          ls -la npm/
          
      - name: Publish to npm
        working-directory: ./npm
        run: |
          echo "Publishing package to npm..."
          echo "Package name: $(jq -r '.name' package.json)"
          echo "Package version: $(jq -r '.version' package.json)"
          echo "Current working directory: $(pwd)"
          echo "Files in directory:"
          ls -la
          echo "Full package.json content:"
          cat package.json
          
          # Check npm authentication
          echo "Testing npm authentication..."
          npm whoami || echo "npm whoami failed"
          
          # Publish with public access for scoped package
          echo "Attempting to publish..."
          npm publish --access public --verbose || {
            echo "npm publish failed with exit code $?"
            echo "npm config:"
            npm config list
            echo "Checking .npmrc file..."
            cat ~/.npmrc || echo "No .npmrc file found"
            exit 1
          }
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_PUBLISH_TOKEN }}

  homebrew-release:
    runs-on: ubuntu-latest
    needs: publish-npm
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Extract version from tag or input
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "CLEAN_VERSION=${VERSION#v}" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Download release assets
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          echo "Downloading assets for version: $VERSION"
          
          # Create download directory
          mkdir -p downloads
          
          # Download tar.gz file (assuming it follows the pattern from build-and-package.yml)
          # We'll look for files that match common patterns
          RELEASE_URL="https://api.github.com/repos/${{ github.repository }}/releases/tags/$VERSION"
          
          # Get release info
          curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               "$RELEASE_URL" \
               -o release_info.json
          
          # Extract download URLs for tar.gz files
          jq -r '.assets[] | select(.name | endswith(".tar.gz")) | .browser_download_url' release_info.json > download_urls.txt
          
          # Download the first tar.gz file found
          if [ -s download_urls.txt ]; then
            DOWNLOAD_URL=$(head -n1 download_urls.txt)
            FILENAME=$(basename "$DOWNLOAD_URL")
            echo "Downloading: $DOWNLOAD_URL"
            curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 -L "$DOWNLOAD_URL" \
                 -o "downloads/$FILENAME"
            echo "ARCHIVE_FILE=downloads/$FILENAME" >> $GITHUB_ENV
            echo "ARCHIVE_NAME=$FILENAME" >> $GITHUB_ENV
          else
            echo "No tar.gz files found in release assets"
            exit 1
          fi
          
      - name: Calculate SHA256 checksum
        id: checksum
        run: |
          CHECKSUM=$(sha256sum "$ARCHIVE_FILE" | cut -d' ' -f1)
          echo "SHA256=$CHECKSUM" >> $GITHUB_OUTPUT
          echo "Archive: $ARCHIVE_FILE"
          echo "SHA256: $CHECKSUM"
          
      - name: Generate Homebrew formula
        run: |
          VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          SHA256="${{ steps.checksum.outputs.SHA256 }}"
          ARCHIVE_NAME="${{ env.ARCHIVE_NAME }}"
          
          # Create formula directory
          mkdir -p formula
          
          cat > formula/kaitu.rb << EOF
          class Kaitu < Formula
            desc "Kaitu - A powerful application tool"
            homepage "https://github.com/${{ github.repository }}"
            url "https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${ARCHIVE_NAME}"
            sha256 "${SHA256}"
            version "${VERSION}"
          
            def install
              # Extract the archive
              system "tar", "-xzf", cached_download
              
              # Install binaries and files
              # Adjust these paths based on your application structure
              if File.exist?("kaitu")
                bin.install "kaitu"
              end
              
              # Install other files if present
              if Dir.exist?("lib")
                lib.install Dir["lib/*"]
              end
              
              if Dir.exist?("share")
                share.install Dir["share/*"]
              end
            end
          
            test do
              # Basic test to ensure the binary exists and runs
              system "#{bin}/kaitu", "--version" if File.exist?("#{bin}/kaitu")
            end
          end
          EOF
          
          echo "Generated Homebrew formula:"
          cat formula/kaitu.rb
          
      - name: Setup Git for Homebrew tap
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
      - name: Update Homebrew tap
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
          HOMEBREW_TAP_REPO: ${{ secrets.HOMEBREW_TAP_REPO }}
        run: |
          VERSION="${{ steps.get_version.outputs.CLEAN_VERSION }}"
          
          if [ -z "$HOMEBREW_TAP_TOKEN" ] || [ -z "$HOMEBREW_TAP_REPO" ]; then
            echo "Warning: HOMEBREW_TAP_TOKEN or HOMEBREW_TAP_REPO not set"
            echo "Please configure these secrets to enable Homebrew tap updates"
            echo "Generated formula is available in the artifacts"
            exit 0
          fi
          
          # Clone the Homebrew tap repository
          git clone https://${HOMEBREW_TAP_TOKEN}@github.com/${HOMEBREW_TAP_REPO}.git homebrew-tap
          cd homebrew-tap
          
          # Create Formula directory if it doesn't exist
          mkdir -p Formula
          
          # Copy the generated formula
          cp ../formula/kaitu.rb Formula/kaitu.rb
          
          # Commit and push changes
          git add Formula/kaitu.rb
          git commit -m "Update kaitu to version ${VERSION}"
          git tag "kaitu-${VERSION}"
          git push origin main
          git push origin "kaitu-${VERSION}"
          
          echo "Successfully updated Homebrew tap with version ${VERSION}"
          
      - name: Upload formula as artifact
        uses: actions/upload-artifact@v4
        with:
          name: homebrew-formula
          path: formula/kaitu.rb
          retention-days: 30